(* This algorithm seems pretty fast in performance as its name suggests, though it's not easy to
implement even if getting the gist of how the sorting algorithm works is not that difficult.

This sorting algorithm uses recursion extensively, so make sure you are quite familiar with
recursion, and have used it a lot before trying to understand the algorithm. The quick sort
works by using a "pivot". The pivot is an index pointer just like the ones used in previous
sorting algorithms. The purpose of the pivot is to divide the list in two halves, one with
elements greater than the pivot and the other with elements smaller than the pivot. The pivot
is usually chosen to be the left-most element of the list, however it is not necessary and one
may choose any random element from the list to be the pivot. Up till now, we have got the
array list divided into two halves. Now, we do the same procedure over this two halves just
like we did to the whole list - and this is what we call recursion. The longer the list, the more
recursion there will be - thus more resources are requested i.e. memory space.

Quick-sort's worst case is when the list is already sorted and choosing the left-most element
as the pivot - this will obviously be a very lengthy process which turns out to be inefficient
for sorting an already sorted list using a quick sort. One may think of keeping a state variable
which keeps track whether a list is already sorted or not and avoid using quick sort to check if
an algorithm is sorted or not. Also, if the list to be sorted has got only 1 or less elements, the
function returns.

To summurize, the following steps are fundamental in doing a quick sort:

If array has got 1 or less elements, then return.
Choose a pivot from the list.
The array is divided into two sections - one with elements smaller than the pivot, the other
with larger elements than the pivot
Use recursion to do the first three steps again, operating on the two divided halves *)

Procedure QSort(numbers : Array of Integer; left : Integer; right : Integer);
Var
	pivot, l_ptr, r_ptr : Integer;

Begin
	l_ptr := left;
	r_ptr := right;
	pivot := numbers[left];

	While (left < right) do
	Begin
		While ((numbers[right] >= pivot) AND (left < right)) do
			right := right - 1;
		If (left <> right) Then
		Begin
			numbers[left] := numbers[right];
			left := left + 1;
		End;

		While ((numbers[left] <= pivot) AND (left < right)) do
			left := left + 1;

		If (left <> right) Then
		Begin
			numbers[right] := numbers[left];
			right := right - 1;
		End;
	End;

	numbers[left] := pivot;
	pivot := left;
	left := l_ptr;
	right := r_ptr;

	If (left < pivot) Then
		QSort(numbers, left, pivot-1);

	If (right > pivot) Then
		QSort(numbers, pivot+1, right);
End;

Procedure QuickSort(numbers : Array of Integer; size : Integer);
Begin
	QSort(numbers, 0, size-1);
End;